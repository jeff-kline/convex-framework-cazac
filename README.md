# Convex SOCP code listing (CAZAC / circulant Hadamard)

This repo contains a **runnable transcription** of the Python code listing included in the manuscript
*A Convex Programming Framework for Constructing CAZAC Sequences*.

The script solves the **augmented second‑order cone program** described in the paper’s phase‑constraint section,
then constructs a **block‑circulant complex Hadamard matrix** of size `(2n)×(2n)`:
\[
  H = \begin{pmatrix} X & Y \\ -Y^* & X^* \end{pmatrix},
\]
where `X` and `Y` are circulant matrices generated by two length‑`n` sequences.

## What the optimization enforces

Variables are `N` complex sequences `x_1, …, x_N ∈ C^n` (the listing uses `N=2`).

- **Amplitude bound** (outer approximation to constant modulus): `|x_j(k)| ≤ τ`
- **Joint spectral flatness bound**: `∑_j |FFT(x_j)(k)|^2 ≤ N n`
- **Phase‑window constraints** around the vertices of a regular `2q`‑gon (listing uses `q=2`, i.e. a square):
  the constraints are implemented exactly as in the listing using `ω_k = exp(i π (1/2 + k)/q)` and a slack `σ`.

The algorithm runs a short **presolve loop** that tightens `τ`, followed by a main loop at `τ=1` that updates the
objective direction `r` to the last solution.

## Quick start

Create a virtual environment and install dependencies:

```bash
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```

Run the listing:

```bash
python cazac_code_listing.py
```

You should see output similar to 

```bash
Time (s):      5.5
Max |H(j,k)| 1.00000e+00
Min |H(j,k)| 1.00000e+00
Size H       (106, 106)
Condition(H) 1.00000e+00
```

## Parameters

In `main()` you can change:

- `n` : base sequence length (matrix is `2n × 2n` when `N=2`)
- `N` : number of coupled sequences (the block construction is implemented for `N=2`)
- `q` and `sigma` : phase‑window polygon and slack
- `L0`, `L`, `eps` : iteration counts and stopping tolerance
- `solver` : preferred cone solver (default tries Clarabel, then falls back)

## Notes

- The listing forms the DFT matrix via `F = fft(I_n)`, which is convenient but uses **O(n²)** memory.
  This is fine for the moderate sizes used in the manuscript experiments.
- CVXPY solver availability varies by platform. The script will try `CLARABEL`, then `ECOS`, then `SCS`.

## Appendix: Extending Alternating Projections (IPUC) to \(N>1\) — reference implementation (`iterated.py`)

This appendix describes the straightforward extension of *iterative projection onto the unimodular torus* (IPUC) to a **family** of \(N\) length-\(n\) sequences, together with an implementation in the adjacent file `iterated.py`.

### Goal (coupled CAZAC-style feasibility)

We seek \((x_1,\dots,x_N)\in(\mathbb{C}^n)^N\) such that:

1. **Unit-modulus (time domain)** for each sequence:
   \[
   |x_j(k)| = 1 \quad \forall j\in\{1,\dots,N\},\ \forall k.
   \]
2. **Coupled spectral flatness (frequency domain)** across the family:
   \[
   \sum_{j=1}^N |F(x_j)(\ell)|^2 = Nn \quad \forall \ell,
   \]
   where \(F(\cdot)\) is the length-\(n\) DFT.

In `iterated.py`, the second condition is encoded as a per-frequency **total power constraint** across the stacked spectra.

---

### Alternating-projection iteration

The iteration alternates between:

#### (A) Projection onto the unimodular torus (componentwise)
Given current \(x_j\), enforce unit modulus by
\[
x_j(k)\leftarrow \frac{x_j(k)}{|x_j(k)|+\texttt{tiny}}.
\]
This is implemented exactly as:
- `seqs = [s / (np.abs(s) + tiny) for s in seqs]`

#### (B) “Projection” onto the coupled spectral constraint \(S_N\)
Compute spectra \(X_j = F(x_j)\). For each frequency bin \(\ell\), enforce
\(\sum_j |X_j(\ell)|^2 = Nn\) by applying a *shared* scaling across all sequences at that bin:
\[
X_j(\ell)\leftarrow X_j(\ell)\cdot \sqrt{\frac{Nn}{\sum_i |X_i(\ell)|^2+\texttt{tiny}}}.
\]

In `iterated.py` this is vectorized as:
- `spectra = [fft(s) for s in seqs]`
- `P = sum(|S_j|^2) + tiny` (a length-\(n\) vector over bins)
- `s = sqrt((N*n)/P)` (length-\(n\) vector)
- `spectra = [S_j * s for S_j in spectra]`

Then transform back with inverse FFT and re-apply unit-modulus normalization.

---

### Convergence check used in `iterated.py`

The function

- `discrepancy_N(seqs)`

computes the max deviation from the coupled spectral constraint:
\[
\max_{\ell}\left|\sum_{j=1}^N |F(x_j)(\ell)|^2 - Nn\right|.
\]
The main loop stops when `discrepancy_N(seqs) <= eps`.

---

### How to run (as in the file)

`iterated.py` includes a small driver:

- sets `n = 103`, `N = 4`,
- calls `generate_cazac_family(...)`,
- prints basic diagnostics (iterations, convergence, final discrepancy, min/max modulus),
- verifies the normalized per-bin power statistic.

Key entry point:

- `generate_cazac_family(n, N=4, eps=..., max_iter=..., seed=..., real=False, verbose=True)`

Notes:
- `real=True` forces the iterates back to `np.real(...)` after each inverse FFT; this is a *heuristic* restriction and does not preserve unimodularity in general without the subsequent normalization step.
- A small constant `tiny = 1e-15` prevents division-by-zero in normalization/scaling.

---

### Relationship to the convex refinement method in the letter

This \(N>1\) IPUC extension is simple and often fast when feasibility is favorable, but it differs from the convex refinement framework emphasized in the main text:

- Each iteration is **not** the globally optimal solution of a convex subproblem (it is a sequence of closed-form normalizations).
- Adding additional convex side constraints (e.g., phase-window constraints, linear/SOC restrictions) generally breaks the closed-form projection structure and requires a different algorithmic backbone.

(These points motivate the convex refinement approach in the letter while still acknowledging the practicality of alternating projections for some regimes.)

## License

The manuscript states the code listing is released under **GNU GPL v3**.
If you publish this as a public repository, include a `LICENSE` file with the GPL‑3.0 text.

## Citation

If you use this code in academic work, cite the associated manuscript and the final venue version (once published).
